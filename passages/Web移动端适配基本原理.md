---
title: Web移动端适配基本原理
date: 2017-04-15 22:11:03
category: 技术
tags: [前端, 移动端, 响应式]
---
这几天看了一些移动端适配的方案，来写一下这篇讨论。理解可能有欠缺之处，欢迎指出。

# 从PC端讲起
虽然这篇是总结移动端的，但是考虑到像我这种学习前端的萌新都是从PC端开始练起，所以我们就先来看下在PC端做前端开发的情况。

写一个h5页面。
``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
    <h1>Hello World!</h1>
</body>
</html>
```
![HelloWorld页面](/image/2017-04-15_22-52-26屏幕截图.jpg)

什么？这不是HTML入门的第一个页面么？这有什么看头？

别急呀，我们现在来看这个页面可不是学标签的。作为一名成长中的前端开发人员，在看到页面的时候要习惯性地问自己一些问题的。比如说对这个页面里，h1到底有多宽?
> 解决问题的最有效方法是提出最正确的问题

<!--more-->

分析一下，首先我们知道h1是一个块级元素，那么块级元素的宽度是怎么定义的呢？
> 块级元素占据其父元素（容器）的整个空间

现在，h1有多宽的问题就变成了另一个问题：h1的父元素——也就是说body,有多宽？

因为我们没有定义body，但根据开发经验我们都知道，不就是100%么（不考虑浏览器自带的padding和margin的话）？但是如果是100%，我们知道百分比是相对大小，那么这个100%是相对于哪个元素来说呢？

唔……应该是浏览器宽度吧，body哪里还会有相对的父元素呢？不，确实有，这是因为我们平时开发时，很少关注一个重要的标签，也就是HTML真正的包裹标签——html。

我们做一个实验，在Chrome下F12打开Console，然后给html加一个width:50%，再查看body的宽度，发现body和html具有一样的宽度。

![chrome实验查看html标签与body标签间的关系](/image/2017-04-15_22-43-54屏幕截图.jpg)

也就是说，默认情况下，body的宽度是相对html的100%。那么问题就成了html有多宽呢？这回总该是浏览器的宽度了吧？

没问题，至少，据我所知在**PC端**的情况下没问题。不要担心我欺骗你们，我们后面会用一些实验证明这一点的。

不过这句话的意思是，在移动端就不是这样了么？html的默认宽度不是浏览器的宽度还能是什么？
是什么呢？亲自看一下吧。

## 阶段结论
1. 在PC端下，html默认宽度恒等于浏览器宽度

# 转战移动端
我这里的意思不是说把上面的网页拷贝到手机上运行，那样太麻烦了，会让人放弃前端开发的。庆幸Chrome里面为开发者提供了一个移动端模拟模拟器。

还是上面那个网页，我们使用用Chrome Console里自带的模拟移动端的功能查看效果（Win键盘快捷键Ctrl+Shift+M）

![chrome模拟手机页面](/image/2017-04-16_14-25-08屏幕截图.png)

我们可以在模拟界面最上面看到我现在模拟的是iphone5的手机(啊，还是很希望有一部真的果机来测试2333)，它的屏幕大小是320x568px，后面的100%意思是在浏览器里显示的屏幕大小，是它在真实世界里大小的100%。

然后按照PC端的思路，html是浏览器的大小，在这里就该是320px，我们看一下。

![移动端html宽度计算](/image/2017-04-15_23-01-28屏幕截图.jpg)

嗯？发生了什么，好像和想象中的不太一样……我们看到在320px宽度的设备上，html标签宽度的计算结果是980px？这难道只是Chrome移动端计算元素宽度时的BUG？

嗯，让我们修改一下html的代码。我想你应该知道在PC端如果想让一个元素隐藏除了用display:none或者visibility:hidden（PS：如果你不知道这两个方法，建议研究一下它们的区别。[What is the difference between visibility:hidden and display:none?](http://stackoverflow.com/questions/133051/what-is-the-difference-between-visibilityhidden-and-displaynone)）还可以把它移动到可见范围之外，比如在1080宽的屏幕上可以left:1080px（当然……没人会蠢到写这种东西吧，这里只是为了实验。如果想实现这种效果请不要使用px这种绝对长度作为单位），我们希望在320px宽度的手机上也实现类似的效果。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
    <h1>Hello World!</h1>
    <p style="position: absolute; left: 600px">
        I shouldn't be seen under the smartphone 
        whose device-width is lower than 600px
    </p>
</body>
</html>
```
然后假设你忘了亲自看一眼就自信的把它提交给了测试……不出1分钟，你就会获得一个BUG反馈

![这是个什么鬼？怎么能让用户看到这种东西？！](/image/2017-04-15_23-17-29屏幕截图.jpg)

这是什么鬼？怎么能让用户看到这种东西？！
> 写前端在时间允许的情况下，请务必多调试多调试多调试，在100种设备上调试都不为过

很好，现在你应该理解了，html的宽度在移动端的奇怪现象了吧。

但是如果这个现象真的不合理，那么全世界的程序员不会这么长时间都坐视不理的。

那么现在的问题是：为什么要在一个320px宽的设备上把html宽度设定成“不规矩”的值呢？

## 阶段结论
1. 在移动端下，html宽度不一定等于浏览器宽度

# 移动端设备厂商 & 移动端浏览器厂商
现在暂时回到几年前，那时候以iPhone和Android为代表的智能机还没出现在市场。没有多少人能想到，现在的我们可以抱着装在口袋里的东西浏览各种高端酷炫的网页，手机上能把html加载出来再把基本的CSS支持一下就已经很了不起了。所以说当然也没有人闲的无聊会想着去开发一些能够在320px宽度下正常显示的页面。

所以当智能机出现的时候，设备厂商和浏览器厂商费尽心思要做的第一件事儿就是，想办法让PC上那些横向设计的html，正确且正常的在320px宽（甚至更窄）的设备上显示。WOW！这个想法很棒，我们只要把大的页面映射到小的屏幕上就可以解决问题了。

映射？这似乎是一个新概念，但是我们大概很久以前就在接触它了。
>如果你学过一些图像处理的知识，你应该知道要把一张2\*2像素的图片显示到4\*4像素的设备上，最简单的方法只需要把原始图片每1个像素(1\*1格)，复制到设备中的4个像素(2\*2格)上就可以了,这就是一种基本的1=>2映射。<br/>当然也可以反过来把4\*4像素的图片显示在2\*2的设备上，只需要只取奇/偶数行奇/偶数列，或者做一些均值计算就可以了，这就是一种2=>1映射

但是还剩一个问题……我们怎么知道html应该有多宽？我们刚才知道在PC端html的宽度是由浏览器宽度决定的？但是在移动端呢，应该让html取多宽？

至于这一点的答案……认真考虑一下其实就能得出，具体多宽其实无所谓，只要足够宽能够防止html下的元素挤在一起就好，当然如果太宽的话，在“初始缩放”映射后，就会导致那些按绝对尺寸定义的元素显得太小。

不过比起随机选一个“足够宽”的数，为所有网页统一定义一个默认宽度明显比较方便。

遗憾的是，这个数字怎么选择并没有一个固定的标准。各个设备厂商&各个浏览器厂商完全可以由着自己的性子来。它们一般都选在768px ~ 1024px之间的一个数，大多数都选择了980px。

我们现在不打算讨论视图的问题，所以我们姑且叫这个数字为default_html_width。

这样，页面在移动端加载时，移动端浏览器会将html.width设定为default_html_width，之后为页面建立一个default_html_width => device_width的映射关系，这个映射关系被苹果公司叫做“初始缩放”，虽然我觉得这个名字……很糟糕(它和下面说的缩放混为一谈了)，但大家现在都么叫。

我们现在可以考虑在浏览器加载HTML时，发生了如下对话
> PC端<br/>
  HTML页面妹子：浏览器大叔，我要请你帮我绘制一下，请问你能给我的最大的绘制空间是多少呀？<br/>
  浏览器大叔：哦，好的，我查一下，我现在有1080px的宽度可以让你绘制 <br/>
  HTML页面妹子：嗯嗯，我知道了，谢谢大叔。（把1080作为html标签的宽度）

> 移动端<br/>
  HTML页面妹子：浏览器大叔，我要请你帮我绘制一下，请问你能给我的最大的绘制空间是多少呀？<br/>
  浏览器大叔：哦，好的，我查一下……（……怎么只有320px，不够妹子用啊！好在爹爹以前教导我，遇到这种情况，就告诉妹子有980px，然后我来把它映射到320px就好了）……哦，我现在有980px的宽度可以给你绘制<br/>
  HTML页面妹子：嗯嗯，我知道了，谢谢大叔。（把980作为html标签的宽度）<br/>
  （之后HTML妹子在绘制的时候，浏览器大叔都会把HTML妹子绘制的像素映射到设备实际的像素）

那么现在事情就变得有意思了，比如说，CSS设置的一个width:100px的button，在宽度为320px宽的设备下实际占多少像素呢？

哈，这个数学题还是难不倒我们的。如果按照default_html_width是980px考虑的话，那么实际像素x有映射关系x / 100 = 320 / 980, x = 33px。取整是因为没人（也没有机器）知道怎么渲染半个像素。

不过这个按钮有多大或许不甚重要（不过你要是不小心弄出了一个超级大的按钮，估计设计师会追着打你……）,这里更重要的东西是**写在代码里的像素需要经过映射才能变为设备上的像素**。

这就有点复杂了，不过问题还没完……

## 阶段结论
1. 设备厂商&浏览器厂商会为网页选定一个default_html_width，并以此为基础建立“初始缩放”映射关系
2. 写在代码里的像素需要经过映射才能变为设备上的像素

# 天呀，这个网页上的字实在是太小了
在default_html_width = 980px的情况下，对于正常情况下一个16px的汉字（它在PC端显示很正常），放到移动端占据的真实像素就是5px。

![优雅的PC端](/image/2017-04-16_15-15-10屏幕截图.png)

![你能看见这个页面到底说了什么么？](/image/2017-04-16_15-16-24屏幕截图.png)

下面的这个显示的效果，就是真实世界里的效果，没有进行缩放，你也可以拿真机试试。别说是文字了，就连标题读起来都心累。

我们要理解，之所以移动端显示PC的页面要经过“初始缩放”映射。是**让用户能知道页面各个位置的布局和功能**。

但是至于看清了布局能不能看清文字……单凭“初始缩放”映射还真解决不了这个问题，所以用户就会双击触屏或者进行手势操作，对他感兴趣的部分进行放大（当然之后很可能还会缩小回原来的样子）……

嗯……等等……放大……放大……放大？

我们对比一下在PC端的经验，有些时候我们在浏览网页的时候偶尔也会调节浏览器的大小。这也是一种放大缩小的行为，那么这个行为是不是和手机端的缩放原理一样呢？

我们知道在PC上，如果为body的直接子元素定义相对宽度的话，当浏览器大小改变时（更准确地说是浏览器大小改变引发了html尺寸的改变），该子元素占据的像素数会被重新计算。我们看一下这个过程（仅在PC端有效）：
1. 定义相对宽度的元素是根据其父节点宽度的像素值计算而来的
2. 当父节点宽度改变的时候子节点会重新计算宽度像素值
3. html的宽度默认恒等于浏览器宽度
4. 浏览器宽度改变时，html宽度改变，body被重新计算，body下所有定义相对宽度的子元素均重新计算。

> Talk is cheap, show me the code

我们来实际看看浏览器大小改变时的效果。

首先把之前的代码改一下。我们来准备一个占body100%大小的ul，为了能观察到变化情况，在下面添加10个li，内容对应0-9，每个宽度占据ul的10%。

哦，我忘了li是块级元素，不能并排在同一行。不过没关系，我们把它改成行内块级（display:inline-block）元素，这样就可以在显示在行内的情况下修改它的宽度。（ps:行内非替换元素修改width属性无效，如果你不知道，请看)
1. [what is a non-replaced inline element?](http://stackoverflow.com/questions/12468176/what-is-a-non-replaced-inline-element)
2. [Inline elements and padding](http://maxdesign.com.au/articles/inline/)
3. [Visual formatting model details](https://www.w3.org/TR/REC-CSS2/visudet.html#Computing_widths_and_margins)

另外，在设置inline-block的时候需要特别注意标签间的空格以及分行，因为它们都会被浏览器当做内部的文本节点" "（占据1em的大小）被渲染出来。

最后，为了让每个元素占据的空间更明显，我们给它设置一个1px的border。但这会导致li的盒模型在content-area.width = 10% \* ul.width的基础上，左右两边各多出1px
那么10个li合起来就占据了(10% \* ul.width + 2) \* 10的宽度，很明显超出父元素20px，导致换行。

这时候我们可以设置box-sizing:border-box;意思就是width:10%这个宽度包含了content,padding,border的全部内容。（也可以用calc函数动态计算width）
> 参见
> [CSS3 box-sizing 属性](http://www.w3school.com.cn/cssref/pr_box-sizing.asp)
> [CSS3 calc() 函数](https://www.w3schools.com/cssref/func_calc.asp)

然后我们的样式有点多了，最好把它们都提出来，标签内嵌样式实在是太丑陋了。下面是修改后的代码
``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <style>
       .p_should_hide{
            position: absolute;
            left: 600px;
       }
       .100button{
            width: 100px;
       }
       .16font_size{
            font-size: 16px;
       }
       ul{
            width: 100%;
            padding: 0;
            margin: 0;
       }
       ul li{
            display: inline-block;
            width: 10%;
            box-sizing: border-box;
            border: 1px solid #000;
       }
    </style>
</head>
<body>
    <h1>Hello World!</h1>
    <p class="p_should_hide">I shouldn't be seen under the mobile browser</p>
    <button class="100button">我是100px宽的按钮</button>
    <p class="16font_size">设计师给我的设计方案是16px,看起来在PC上很优雅</p>
    <ul>
        <li>0</li>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
        <li>6</li>
        <li>7</li>
        <li>8</li>
        <li>9</li>
    </ul>
</body>
</html>
```
我们可以看到在PC下，窗口放小的过程中，html一直等于窗口的宽度，并且ul,li的宽度一直被重新计算

![在PC下将窗口调到最小_原理](/image/2017-04-16_15-29-32屏幕截图.png)

导致所有计算结果的原因归根结底就是PC端html的宽度恒等于浏览器的宽度。

让我们回到移动端，html的宽度……额……和浏览器的宽度，有一个“初始映射关系”。而且在缩放过程中，移动端浏览器的宽度也根本不会变啊。

所以结论很明显，移动端的缩放机制和PC端浏览器窗口大小改变的原理绝对不一样。

那么新的问题又来了，移动端缩放的过程中到底发生了什么？

## 阶段结论
1. html元素宽度的改变的根本原因在于html宽度的改变
2. 移动端的缩放机制和PC端浏览器窗口大小改变的原理不一样

# PC上的缩放
移动端缩放这个问题，还是有点复杂。

但我们先不管移动端，只考虑缩放的问题。

不知道你有没有注意过，其实现代的PC浏览器上一般都会有缩放的功能，这是为了满足一些视力不太好的用户（当然有时候也能帮助一些设计尺寸很反人类的网页）的需求

在Chrome下按Ctrl+"+"/"-",或者Ctrl+鼠标滑轮滚动就能实现页面的缩放。

我们对之前的页面进行175%的缩放

![PC端175%缩放效果](/image/2017-04-16_15-31-43屏幕截图.png)

哈，这下可就麻烦了，我们在上面讨论中的第一个结论就是**PC端下html默认宽度恒等于浏览器宽度**，但是这里明显出了问题，我现在的浏览器宽度是1366px，但是html的计算宽度却只有780.57px。看来我们需要修改一下最初的结论
> 在PC端不进行缩放的情况下，html默认宽度恒等于浏览器宽度

这个结论看起来比之前的那个更复杂了，但是其实这并不会造成太大的问题。因为PC端在布局合理的情况下，很少有用户会开着缩放浏览你的页面呢？

在这里真正有启发性的是缩放的本质，我们计算一下，1366 / 780.57，我的计算器显示为1.750003203，也就是我们的缩放比例。

现在我们可以来梳理一下PC端缩放的过程了：
1. 用户通过缩放工具选择了某个缩放比例
2. 计算缩放后html.width = browser.width / scaleRatio
3. 计算html后代元素的尺寸
4. 重设映射关系html.width => browser.width
关于前面三点都是旧概念了，但这里的第四点重置了映射关系！所以缩放本质上讲就是一种映射关系的改变。

## 阶段结论
1. 在PC端不进行缩放的情况下，html默认宽度恒等于浏览器宽度
2. PC端缩放会改变html.width
3. 缩放本质上讲就是一种映射关系的改变。

# 移动端的用户缩放
好啦，理解了缩放，再来看移动端缩放。

还是拿上面的页面，我们利用Chrome模拟器在移动端进行放大测试（在Chrome模拟器调试时，双击页面进行放大）

![Chrome模拟器中进行调试用户缩放](/image/2017-04-16_12-36-30屏幕截图.png)

唔，这个显示的效果太小了，但我不想利用CSS把它变大，那样不定会导致更麻烦的属性计算问题。

但亲自看一遍放大过程或者数格子就能看出来，在移动端放大后只显示了8.5个格子，查看html的宽度，它还是980px。

![Chrome模拟器中进行调试用户缩放_html宽度](/image/2017-04-16_13-42-18屏幕截图.png)

唔……这就麻烦了，同样是缩放，PC端改变了html的宽度而移动端却没有这么做……但仔细考虑一下这样是合理的，理由就是移动端的浏览器宽度通常很窄。

移动端的浏览器宽度通常很窄，如果在缩放时执行了html.width = origin_html.width / scaleRatio，那么下面的所有定义了相对宽度的元素都会被缩放，然后再进过html.width => browser.width的映射，那么页面上所有的元素就会挤在你小小的屏幕上，即便它们都被放大到很大的倍数……想象一下，那简直就是一锅粥。(tip:如果你想象不到那会有多造，把你的浏览器尺寸拉到最小，然后使用缩放工具试一下你就知道了……)

我们现在解决原始的问题移动端用户缩放时发生了什么：
1. 用户通过手势（扩大手势，缩小手势或者双击）进行
2. 重置映射关系为 (html.width / scaleRatio) => browser.width

我们还是看那个CSS中定义为100px的button，移动端尺寸宽320px，default_html_width为980px，根据之前的计算，这个按钮在不经过缩放的情况下占据实际像素33px。

现在用户进行了一个放大2倍的手势操作。
> 初始映射关系：980px => 320px
  放大后映射关系： (980 / 2)px => 320px

现在再来计算button显示的宽度x: x / 100 = 320 / 490, 得x = 65px。

太棒了，现在我们可以精确知道用户缩放以后的像素了。可是先别急，因为只是知道这个像素……其实……基本上可以说没有任何意义。

## 阶段结论
1. 移动端用户缩放时不会改变html.width，只会修改映射关系。

# 北京到杭州的距离是……1568……px?
作为前端开发人员，我们和设计师交流的必然会涉及px。这个按钮100px，这个div要左移1px等等。而且经过上面的讨论，我们也知道了，**在CSS中写好的像素需要经过映射才呈现出实际的像素**。

不过我还是有个问题，就是到底需要多大的按钮，才能保证用户很容易用手指点中？

略微思考后，你可能想回答某一个像素值，而且它应该是基于实际像素的，但这个像素值有实际意义么？
其实换个角度想，这个问题正确的问法应该是，用户的手指一般有多粗？既然如此……像素值有意义嘛？
这就好比我问你北京到杭州有多远，你思考了一阵告诉我……1568……px。

很明显，现在我们又引出了新的问题，就是1px，在现实世界里，到底该有多长？老师在学校没有教过你这类单位转换，当然也不可能在某某标准单位定义里找到相关的东西。

也就是说，1px的实际长度完全可以是任意的！

好吧，我们好不容易解决了缩放的问题，确定了实际显示的像素大小，但现在却被告知这个大小完全没有意义，它可能代表1cm,1m甚至1km……

怎么办呢？我们完全可以要求全世界的人，规定一个统一的换算单位，比如1px=1cm。但这明显不合理，比如说你想要显示一张1080\*763的图片，你就必须购买一个1080\*763cm的设备……要不然全世界只有少的可怜的几种固定大小的图片，要不然你就得为了欣赏各种图片买齐各种大小的设备……

如果你以前做过任何和图像有关的事情，或者你在学计算机的时候学习过显示器的知识，你就应该知道有一个叫[图像分辨率](https://zh.wikipedia.org/wiki/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0)的概念（为了把它和显示分辨率区别，一般都叫它像素密度……但我觉得分辨率的率本来就该含有密度的意思），它代表了每个单位长度中包含的像素数，但遗憾的是，它的单位长度用的是英寸……作为中国人，我对英寸这个概念实在是没什么亲切感，为了便于后面的理解，请允许我在这篇文章里讨论细节的时候把单位长度换成cm（其实无所谓啦，只是个等比例换算问题而已）。

我们这里就假设有一个宽10cm，高20cm的设备，它的像素密度是32px/cm，所以说它的像素为320\*640，我们就叫它设备A吧。
还有一个同样宽10cm，高20cm的设备，它的像素密度是64px/cm，像素就是640\*1280，我们叫它设备B。

我们来看看那个CSS定义的100px的button在这两个设备上会怎么被映射？

> A设备：
> default_html_width = 980px
> 映射关系： 980 => 320
> 实际像素： x / 100 = 320 / 980 => x = 33px
> 实际长度： l = 33px / 32(px/cm) = 1cm

> B设备：
> default_html_width = 980px
> 映射关系： 980 => 640
> 实际像素： x / 100 = 640 / 980 => x = 65px
> 实际长度： l = 65px / 64(px/cm) = 1cm

WOW！我们发现只要设备厂家和浏览器厂家给出了相同的default_html_width，那么按照映射关系，即便button实际占据的像素数不同，但最后的实际长度基本上是相等的。

不过实际像素的不同会有什么影响呢？比如说我们的button用了一个从左向右的渐变色，再假设渐变方向上的每个元素都有一个新的颜色值。那么对于设备A，就有33种颜色，而设备B有65种颜色。所以这就是高分辨率的意义。

最后我们整理一下在没有用户缩放影响下的实际长度计算公式
> CSS_px => CSS中定义的像素
> device_px => 设备的像素数
> default_html_width => 设备厂商&浏览器厂商给定的默认html宽度
> PPI => 设备像素密度
> device_length => 设备实际长度
> 
> 实际像素： device_px \* CSS_px / default_html_width
> 实际长度： (device_px \* CSS_px) / (PPI \* default_html_width) = device_length \* CSS_px / default_html_width

好，现在我们把这篇文章里的两个主要话题结合起来讨论一个主题作为结尾：
1. 移动端的缩放
2. 移动端的像素密度

我们要讨论的是，如何充分利用高分辨率屏幕的分辨率。出于某些原因（下一篇我们会讨论这些原因），default_html_width = 320px

然后我这里有一张宽320px的图像，我希望让它显示在页面最上面并且充满浏览器的宽度。

根据之前学会的计算方法，我们很容易得到：
> A设备：
> 映射关系： 320 => 320
> 实际像素： x / 320 = 320 / 320 => x = 320px
> 实际长度： l = 320px / 32(px/cm) = 10cm

> B设备：
> 映射关系： 320 => 640
> 实际像素： x / 320 = 640 / 320 => x = 640px
> 实际长度： l = 640 / 64 = 10cm

看起来似乎没什么问题。但是……
> 用户利益至上

我们可以看到，一张320px的图片，在设备B上却实际占据了640px的像素数。换句话说，用户花钱买了高分辨率的设备，就是希望能有更好的用户体验，但是这里却给了他们和设备A相同的结果……（甚至更糟糕……很多图片因为强行放大会变的很奇怪）

站在你的用户的角度考虑，这肯定不合理。那么我们可以为B设备的用户提供更清晰的图片嘛？比如说宽640px的图片。
> B设备：
> 实际像素： x / 640 = 640 / 320 => x = 1280px
> 实际长度： l = 1280 / 64 = 20cm

Oh!太糟糕了，这样子的话在设备A，B上显示的结果就不一致了。

怎么办呢？可不可以利用缩放把图片缩放0.5倍？当然不行……你可以算一下，因为移动端缩放不影响html.width，所以页面内所有元素宽度都不变，然而你把映射关系改成了原像素的0.5倍，那么整个页面的所有元素都会被缩小0.5倍。所以A，B设备之间还是不一致。

但如果我们修改的是html.width呢？或者说，我们修改了B设备的default_html_width。比如说把它改成640px，是不是就解决问题了。

当然，所以这里的正确问题是能不能修改default_html_width的值，或者换句话说，能不能修改“初始缩放”映射关系呢？

好吧，关于这个的答案当然可以，但是具体的内容就放到下一篇讲吧。

## 阶段结论
1. 显示在设备上的实际像素并不代表用户最终见到的尺寸
2. 在没有缩放的情况下，影响最终用户见到的尺寸的因素包括：设备长度，CSS定义，default_html_width

# 总结结论
1. 在PC端不进行缩放的情况下，html默认宽度恒等于浏览器宽度
2. 在移动端下，设备厂商&浏览器厂商会为网页选定一个default_html_width作为默认html.width，并以此为基础建立“初始缩放”映射关系:default_html_width => device_width
3. 写在代码里的像素需要经过映射才能变为设备上的像素
4. 缩放本质上讲就是一种映射关系的改变。
5. html元素宽度的改变的根本原因在于html宽度的改变
6. 移动端的缩放机制和PC端浏览器窗口大小改变的原理不一样
7. PC端缩放会改变html.width
8. 移动端用户缩放时不会改变html.width，只会修改映射关系。
9. 显示在设备上的实际像素并不代表用户最终见到的尺寸
10. 在没有缩放的情况下，影响最终用户见到的尺寸的因素包括：设备长度，CSS定义，default_html_width

